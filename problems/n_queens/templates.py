import random
import threading
from typing import Any

try:
    from . import algorithms
except ImportError:
    import problems.n_queens.algorithms as algorithms

try:
    from ...utils.string_matching import strings_are_similar
except ImportError:
    from utils.string_matching import strings_are_similar


# This is the Base Class for all question templates.
# The controller will look for classes that inherit from this.
class BaseQuestionTemplate:
    # A unique ID for this question template
    id: str = "base_template"
    # The problem domain (e.g., 'n_queens', 'knights_tour')
    problem_type: str = "base"
    # The type of question (e.g., 'Theory', 'Validation', 'Experimental')
    question_type: str = "base"

    def __init__(self):
        # Parameters generated by `generate`
        self.params: dict[str, Any] = {}
        # The formatted question string
        self.question_text: str = ""
        # The prompt for the user's answer
        self.answer_prompt: str = ""
        # Store the correct answer for evaluation
        self.correct_answer: Any = None

    def generate(self) -> dict[str, str]:
        """
        Generates parameters, a question, and an answer prompt.
        This method MUST be overridden by all child classes.

        Returns:
            A dictionary with 'question_text' and 'answer_prompt'.
        """
        raise NotImplementedError

    def evaluate(self, user_answer: str) -> tuple[int, str, str]:
        """
        Evaluates the user's answer.
        This method MUST be overridden by all child classes.

        Args:
            user_answer (str): The raw string from the user.

        Returns:
            A tuple (score, correct_answer_str, explanation)
            - score (int): 0-100
            - correct_answer_str (str): The correct answer to display
            - explanation (str): A detailed explanation
        """
        raise NotImplementedError


# --- Template 1.1: Theory (Time Complexity) ---


class NQ_TheoryComplexity(BaseQuestionTemplate):
    id = "nq_theory_complexity"
    problem_type = "n_queens"
    question_type = "Theory"

    def generate(self) -> dict[str, str]:
        self.params["n"] = random.choice([8, 10, 12, 16])

        # Randomly choose which algorithm to ask about
        algorithm_choices = [
            {
                "name": "standard Backtracking",
                "answer": "o(n!)",
                "display": "O(N!)",
                "explanation": "The algorithm explores a search tree that, in the worst case, has N! leaves, leading to a factorial time complexity.",
            },
            {
                "name": "Hill Climbing",
                "answer": "o(n^2)",
                "display": "O(N²)",
                "explanation": "Hill Climbing iteratively improves a configuration. Each iteration examines O(N²) possible moves (N rows × N positions), and typically converges in a reasonable number of iterations.",
            },
            {
                "name": "Simulated Annealing",
                "answer": "o(n^2)",
                "display": "O(N²)",
                "explanation": "Simulated Annealing is similar to Hill Climbing in terms of complexity per iteration. Each iteration checks O(N²) possible state changes, with convergence dependent on the cooling schedule.",
            },
            {
                "name": "Genetic Algorithm",
                "answer": "o(n^3)",
                "display": "O(N³)",
                "explanation": "Genetic Algorithms maintain a population and perform crossover/mutation operations. The complexity is roughly O(population_size × N² × generations), which typically simplifies to O(N³) for standard configurations.",
            },
        ]

        chosen = random.choice(algorithm_choices)
        self.params["algorithm"] = chosen["name"]
        self.params["explanation_detail"] = chosen["explanation"]
        self.correct_answer = chosen["answer"]
        self.params["display_answer"] = chosen["display"]

        self.question_text = f"What is the time complexity of the {chosen['name']} algorithm for finding {'all solutions' if 'Backtracking' in chosen['name'] else 'a solution'} to the {self.params['n']}-Queens problem?"
        self.answer_prompt = (
            "Please provide the time complexity in Big-O notation (e.g., O(N^2))."
        )

        return {
            "question_text": self.question_text,
            "answer_prompt": self.answer_prompt,
        }

    def evaluate(self, user_answer: str) -> tuple[int, str, str]:
        user_ans_clean = user_answer.strip().lower().replace(" ", "")

        if user_ans_clean == self.correct_answer:
            score = 100
            explanation = f"Correct! The answer is {self.params['display_answer']}. {self.params['explanation_detail']}"
        else:
            score = 0
            explanation = f"Your answer was '{user_answer}'. The correct answer is **{self.params['display_answer']}**. {self.params['explanation_detail']}"

        return (score, self.params["display_answer"], explanation)


# --- Template 1.2: Validation (Placement Viability) ---


class NQ_ValidationViability(BaseQuestionTemplate):
    id = "nq_validation_viability"
    problem_type = "n_queens"
    question_type = "Validation"

    def generate(self) -> dict[str, str]:
        n = random.randint(5, 8)
        num_placed = random.randint(2, n - 2)
        # Generate a valid partial board
        partial_board, _ = algorithms.find_one_n_queens_bt(n)
        if partial_board is None:  # Should not happen for N > 3
            return self.generate()  # Recurse

        partial_board = partial_board[:num_placed]

        next_row = num_placed
        col_to_check = random.randint(0, n - 1)

        self.params = {
            "n": n,
            "partial_board": partial_board,
            "next_row": next_row,
            "col_to_check": col_to_check,
        }

        self.question_text = f"For a {n}-Queens problem, consider the partially filled board: `{partial_board}`. Is it viable to place the next queen (in row {next_row}) at column {col_to_check}?"
        self.answer_prompt = "Please answer 'Yes' or 'No'."

        # Pre-calculate the correct answer
        is_safe, reason = algorithms.is_safe(partial_board, next_row, col_to_check)
        self.correct_answer = "yes" if is_safe else "no"
        self.params["reason"] = reason

        return {
            "question_text": self.question_text,
            "answer_prompt": self.answer_prompt,
        }

    def evaluate(self, user_answer: str) -> tuple[int, str, str]:
        user_ans_clean = user_answer.strip().lower()

        if user_ans_clean == self.correct_answer:
            score = 100
            if self.correct_answer == "yes":
                explanation = f"Correct! The answer is **Yes**. The position ({self.params['next_row']}, {self.params['col_to_check']}) does not conflict on any row, column, or diagonal with the existing queens."
            else:
                explanation = f"Correct! The answer is **No**. Placing a queen at ({self.params['next_row']}, {self.params['col_to_check']}) {self.params['reason']}."
        else:
            score = 0
            if self.correct_answer == "yes":
                explanation = f"Your answer was '{user_answer}'. The correct answer is **Yes**. The position ({self.params['next_row']}, {self.params['col_to_check']}) does not conflict on any row, column, or diagonal with the existing queens."
            else:
                explanation = f"Your answer was '{user_answer}'. The correct answer is **No**. Placing a queen at ({self.params['next_row']}, {self.params['col_to_check']}) {self.params['reason']}."

        return (score, self.correct_answer.capitalize(), explanation)


# --- Template 1.3: Computation (Solution Count) ---


class NQ_ComputationCount(BaseQuestionTemplate):
    id = "nq_computation_count"
    problem_type = "n_queens"
    question_type = "Computation (Async)"

    def generate(self) -> dict[str, str]:
        n = random.randint(4, 9)  # 9 is slow, but ok for async
        self.params["n"] = n

        self.question_text = (
            f"How many distinct solutions are there for the {n}-Queens problem?"
        )
        self.answer_prompt = (
            "Please enter a single integer. If no solution exists, write 'impossible'."
        )

        return {
            "question_text": self.question_text,
            "answer_prompt": self.answer_prompt,
        }

    def evaluate(self, user_answer: str) -> tuple[int, str, str]:
        n = self.params["n"]
        user_ans_clean = user_answer.strip().lower()

        if n == 2 or n == 3:
            self.correct_answer = "impossible"
            count = 0
        else:
            # This is the async part! It will run in a thread.
            solutions, _ = algorithms.solve_n_queens_bt(n)
            count = len(solutions)
            self.correct_answer = str(count)

        if user_ans_clean == self.correct_answer:
            score = 100
            explanation = f"Correct! The answer is **{self.correct_answer}**."
        else:
            score = 0
            explanation = f"Your answer was '{user_answer}'. The correct answer is **{self.correct_answer}**."

        if 4 <= n <= 6 and count > 0:
            # Show solutions for small N
            solutions, _ = algorithms.solve_n_queens_bt(n)
            explanation += f"\nFor N={n}, the {count} solutions are: {solutions}"

        return (score, self.correct_answer, explanation)


# --- Template 1.4: Computation (Find One Solution) ---


class NQ_ComputationFindOne(BaseQuestionTemplate):
    id = "nq_computation_find_one"
    problem_type = "n_queens"
    question_type = "Computation"

    def generate(self) -> dict[str, str]:
        n = random.randint(4, 8)
        self.params["n"] = n

        self.question_text = f"Provide one valid solution for the {n}-Queens problem."
        self.answer_prompt = f"Please provide the solution as an array of {n} indices (e.g., `[1, 3, 0, 2]`). If no solution exists, write 'impossible'."

        return {
            "question_text": self.question_text,
            "answer_prompt": self.answer_prompt,
        }

    def evaluate(self, user_answer: str) -> tuple[int, str, str]:
        n = self.params["n"]
        user_ans_clean = user_answer.strip().lower()

        # Find one correct solution for comparison
        correct_solution, _ = algorithms.find_one_n_queens_bt(n)
        correct_answer_str = str(correct_solution)

        if n == 2 or n == 3:
            if user_ans_clean == "impossible":
                return (
                    100,
                    "impossible",
                    "Correct! It is impossible to solve {n}-Queens.",
                )
            else:
                return (
                    0,
                    "impossible",
                    f"Your answer was '{user_answer}'. The correct answer is 'impossible' for N={n}.",
                )

        # Try to parse user's array
        try:
            # A bit of parsing magic to handle [1, 2, 3] or 1,2,3 or (1, 2, 3)
            user_board = [
                int(x)
                for x in user_answer.replace("[", "")
                .replace("]", "")
                .replace("(", "")
                .replace(")", "")
                .split(",")
            ]

            if len(user_board) != n:
                return (
                    0,
                    correct_answer_str,
                    f"Your solution `{user_board}` is not valid. It must have {n} elements, but yours has {len(user_board)}.",
                )

            # Check if all numbers are valid
            if not all(0 <= x < n for x in user_board):
                return (
                    0,
                    correct_answer_str,
                    f"Your solution `{user_board}` is not valid. All positions must be between 0 and {n - 1}.",
                )

            # Validate the user's board
            is_valid_solution = True
            conflict_reason = ""
            for r in range(n):
                is_safe, reason = algorithms.is_safe(user_board, r, user_board[r])
                if not is_safe:
                    is_valid_solution = False
                    conflict_reason = (
                        f"The queen at row {r} (position {user_board[r]}) {reason}."
                    )
                    break

            if is_valid_solution:
                return (
                    100,
                    str(user_board),
                    f"Excellent! Your solution `{user_board}` is a valid solution.",
                )
            else:
                return (
                    0,
                    correct_answer_str,
                    f"Your solution `{user_board}` is not valid. {conflict_reason}\nA correct solution is **{correct_answer_str}**.",
                )

        except Exception as e:
            return (
                0,
                correct_answer_str,
                f"Your answer '{user_answer}' could not be parsed as an array (e.g., [1, 3, 0, 2]).\nA correct solution is **{correct_answer_str}**.",
            )


# --- Template 1.5: Experimental (Algorithm Race) ---


class NQ_ExperimentalRace(BaseQuestionTemplate):
    id = "nq_experimental_race"
    problem_type = "n_queens"
    question_type = "Experimental (Async)"

    def generate(self) -> dict[str, str]:
        n = random.choice([8, 10, 12, 14, 16])  # Large enough to see differences
        self.params["n"] = n

        self.question_text = f"For a {n}x{n} board (N={n}), which algorithm will find a *single* solution first: Backtracking, Hill Climbing, or Simulated Annealing?"
        self.answer_prompt = "Please enter the name of the algorithm you think will be fastest (e.g., 'Hill Climbing')."

        return {
            "question_text": self.question_text,
            "answer_prompt": self.answer_prompt,
        }

    def evaluate(self, user_answer: str) -> tuple[int, str, str]:
        n = self.params["n"]

        # This is the async part!
        # We run all 3 algorithms and store their results.
        # We use threading.Event to coordinate.

        results = {}

        def run_bt():
            _, time_taken = algorithms.find_one_n_queens_bt(n)
            results["Backtracking"] = time_taken

        def run_hc():
            _, time_taken = algorithms.solve_n_queens_hc(n)
            results["Hill Climbing"] = time_taken

        def run_sa():
            _, time_taken = algorithms.solve_n_queens_sa(n)
            results["Simulated Annealing"] = time_taken

        # Create and start threads
        t_bt = threading.Thread(target=run_bt)
        t_hc = threading.Thread(target=run_hc)
        t_sa = threading.Thread(target=run_sa)

        t_bt.start()
        t_hc.start()
        t_sa.start()

        # Wait for all to finish
        t_bt.join()
        t_hc.join()
        t_sa.join()

        # Find the winner
        # Use a large default time for any algorithm that failed (returned None)
        bt_time = results.get("Backtracking", float("inf"))
        hc_time = results.get("Hill Climbing", float("inf"))
        sa_time = results.get("Simulated Annealing", float("inf"))

        # Create a sorted list of (name, time)
        times = [
            ("Backtracking", bt_time),
            ("Hill Climbing", hc_time),
            ("Simulated Annealing", sa_time),
        ]

        # Filter out any that failed and sort by time
        valid_times = sorted(
            [t for t in times if t[1] != float("inf")], key=lambda x: x[1]
        )

        if not valid_times:
            return (
                0,
                "N/A",
                "All algorithms failed to find a solution for this instance.",
            )

        fastest_algo_name, _fastest_time = valid_times[0]

        self.correct_answer = fastest_algo_name

        # Build explanation
        explanation = f"The fastest algorithm for this instance (N={n}) was **{fastest_algo_name}**.\n\n"
        explanation += "--- Results ---\n"
        explanation += f"1. {valid_times[0][0]}: {valid_times[0][1]:.6f}s\n"
        if len(valid_times) > 1:
            explanation += f"2. {valid_times[1][0]}: {valid_times[1][1]:.6f}s\n"
        if len(valid_times) > 2:
            explanation += f"3. {valid_times[2][0]}: {valid_times[2][1]:.6f}s\n"

        # Check user's answer
        if strings_are_similar(user_answer, self.correct_answer, max_distance=3):
            score = 100
            explanation = "Correct!\n" + explanation
        else:
            score = 0
            explanation = f"Your answer was '{user_answer}'.\n" + explanation

        return (score, self.correct_answer, explanation)
